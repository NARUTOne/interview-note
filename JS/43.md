# å®žçŽ° setInterval

> ç¼–ç¨‹é¢˜

**âš¡é¢˜ç›®**:

â“ ç”¨ setTimeout å®žçŽ° setIntervalï¼Œé˜è¿°å®žçŽ°çš„æ•ˆæžœä¸ŽsetIntervalçš„å·®å¼‚

## ä¼˜è§£ ðŸ”¥

> ä½¿ç”¨setTimeout é€’å½’å®šæ—¶æ‰§è¡Œ

```js

function setInterval_ (fn, timer, args) {
  setInterval_._timer_ && clearTimeout(setInterval_._timer_);
  !setInterval_.clearTimeout_ && (setInterval_._timer_ = setTimeout(() => {
    fn.call(this, args); // åˆ¤æ–­æ­¤å¤„ï¼Œå¼‚æ­¥è¿˜æ˜¯åŒæ­¥ï¼Œ å…ˆæ‰§è¡Œå›žè°ƒå‡½æ•°å†è®¾ç½® settimeout ä¼šå¯¼è‡´ä¸‹æ¬¡æ‰§è¡Œå®žçŽ°ç­‰å¾…æ—¶é—´å¤§äºŽ timeout+åŒæ­¥ä»£ç æ‰§è¡Œæ—¶é—´
    setInterval_(fn, timer, args);
  }, timer));
}

setInterval_.clear = function () {
  this.clearTimeout_ = true;
  clearTimeout(this._timer_);
}

setInterval_(console.log, 1000, "hello world");

setTimeout(() => {
  setInterval_.clear();
}, 5000);

```

é€šè¿‡ node-libuv æºç å¯ä»¥è¯æ˜Ž

```js
void uv__run_timers(uv_loop_t* loop) {
  struct heap_node* heap_node;
  uv_timer_t* handle;

  for (;;) {
    heap_node = heap_min(timer_heap(loop));//å–å‡ºtimerå †ä¸Šè¶…æ—¶æ—¶é—´æœ€å°çš„å…ƒç´ 
    if (heap_node == NULL)
      break;
    //æ ¹æ®ä¸Šé¢çš„å…ƒç´ ï¼Œè®¡ç®—å‡ºhandleçš„åœ°å€ï¼Œhead_nodeç»“æž„ä½“å’Œcontainer_ofçš„ç»“åˆéžå¸¸å·§å¦™ï¼Œå€¼å¾—å­¦ä¹ 
    handle = container_of(heap_node, uv_timer_t, heap_node);
    if (handle->timeout > loop->time)//å¦‚æžœæœ€å°çš„è¶…æ—¶æ—¶é—´æ¯”å¾ªçŽ¯è¿è¡Œçš„æ—¶é—´è¿˜è¦å°ï¼Œåˆ™è¡¨ç¤ºæ²¡æœ‰åˆ°æœŸçš„callbackéœ€è¦æ‰§è¡Œï¼Œæ­¤æ—¶é€€å‡ºtimeré˜¶æ®µ
      break;

    uv_timer_stop(handle);//å°†è¿™ä¸ªhandleç§»é™¤
    uv_timer_again(handle);//å¦‚æžœhandleæ˜¯repeatç±»åž‹çš„ï¼Œé‡æ–°æ’å…¥å †é‡Œ
    handle->timer_cb(handle);//æ‰§è¡Œhandleä¸Šçš„callback
  }
}
```
