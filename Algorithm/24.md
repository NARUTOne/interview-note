# P24

> æ•°æ®ç»“æ„é¢˜

**âš¡é¢˜ç›®**:

â“ JSæ¨¡æ‹Ÿå•å‘é“¾æ•°æ®ç»“æ„

## ä¼˜è§£ ğŸ”¥

```js
 /**
    å•å‘é“¾è¡¨

    é“¾è¡¨ï¼šç”±å¤šä¸ªèŠ‚ç‚¹æ„æˆï¼Œæ¯ä¸ªèŠ‚ç‚¹åŒ…å«è‡ªèº«æ•°æ®å’ŒæŒ‡å‘ä¸‹ä¸ªèŠ‚ç‚¹çš„å¼•ç”¨
         ç‰©ç†ä¸Šå¯ä»¥ä¸è¿ç»­ä½†é€»è¾‘ä¸Šå¿…é¡»è¿ç»­ï¼ˆä¸ä¸€å®šæ˜¯ä¸€å—è¿ç»­çš„å†…å­˜ï¼‰

    é“¾è¡¨æ˜¯ä¸€ç§å¸¸è§çš„åŸºç¡€æ•°æ®ç»“æ„ï¼Œæ˜¯ä¸€ç§çº¿æ€§è¡¨ï¼Œä½†æ˜¯ä¸ä¼šæŒ‰çº¿æ€§çš„é¡ºåºå­˜å‚¨æ•°æ®è€Œæ˜¯æ¯ä¸ªèŠ‚ç‚¹å­˜æŒ‡å‘ä¸‹ä¸ªèŠ‚ç‚¹çš„å¼•ç”¨
 */
class LinkNode {
    constructor(val) {
        if (val === void 0) throw new Error('è¯·è¾“å…¥é“¾è¡¨èŠ‚ç‚¹å€¼')
        this.node = val
        this.next = null
    }
}

class LinkList {
    head = null
    size = 0

    // æœ‰æ²¡æœ‰åˆå§‹åŒ–çš„æ–¹æ³•å‘¢ ï¼Ÿï¼Ÿï¼Ÿ
    initLinkedList() {}

    /**
    * @description: æ ¹æ®ç´¢å¼•è·å– nodeï¼Œä»å¤´éƒ¨éå†
    * @param {index}
    * @return: linkNode
    */
    findNode(index) {
        if (index < 0 || index >= this.size || this.size == 0) return null
        let node = this.head
        for (let i=0; i<index; i++) {
            if (!node) return null
            node = node.next
        }
        return node ? node : null
    }

    // æ—¶é—´å¤æ‚åº¦ O(n)
    get(index) {
        return this.findNode(index)
    }

    // æ—¶é—´å¤æ‚åº¦ O(n)
    push(val) {
        const node = new LinkNode(val)
        if (!this.head) {
            this.head = node
        } else {
            let tail = this.findNode(this.size - 1)
            tail.next = node
        }
        this.size++
        return this
    }
    // æ—¶é—´å¤æ‚åº¦ O(1)
    unshift(val) {
        const node = new LinkNode(val)
        if (!this.head) {
            this.head = node
        } else {
            let temp = this.head
            this.head = node
            this.head.next = temp
        }
        this.size++
        return this
    }
    // æ—¶é—´å¤æ‚åº¦ O(1)
    shift() {
        if (!this.head) return -1
        this.head = this.head.next
        this.size--
        return this
    }
    // æ—¶é—´å¤æ‚åº¦ O(2n)
    pop() {
        return this.removeAtIndex(this.size-1)
    }
    // æ—¶é—´å¤æ‚åº¦ O(2n)
    removeAtIndex(index) {
        if (!this.head || index >= this.size || index < 0 || this.size == 0) return

        const prevNode = this.findNode(index-1)
        const nextNode = this.findNode(index+1)
        const currNode = this.findNode(index)
        // æ­£å¸¸æƒ…å†µ
        if (prevNode && nextNode) {
            prevNode.next = nextNode
        }
        // ç´¢å¼•ä¸º 0, size å¤§äº 1 === shift
        if (!prevNode && nextNode) {
            this.head = this.head.next
        }

        // ç´¢å¼•ä¸º size-1 === pop
        if (prevNode && !nextNode) {
            prevNode.next = null
        }

        // ç´¢å¼•ä¸º 0ï¼Œsizeä¸º 1
        if (!prevNode && !nextNode) {
            this.head = null
        }
        this.size--
        return currNode
    }

    // æ—¶é—´å¤æ‚åº¦ O(2n)
    addAtIndex(val, index=this.size) {
        const node = new LinkNode(val)
        if (!node && (index > this.size || index < 0)) return

        // å°¾ä¸è¿½åŠ 
        if (this.size === 0 || index === this.size) return this.push(node)

        // å¤´éƒ¨è¿½åŠ 
        if (index === 0) return this.unshift(node)

        // ä¸­é—´éƒ¨ä½
        const prevNode = this.findNode(index-1)
        const nextNode = this.findNode(index+1)

        prevNode.next = node
        node.next = nextNode
        this.size++
        return this
    }

    // æ¸…ç©ºå•é“¾è¡¨
    clear() {
        this.head = null
        this.size = 0
        return this
    }

    // ç¿»è½¬é“¾è¡¨
    reverse() {
        if (this.head === null || this.head.next === null) return this.head
        // ... å¾…æ›´æ–°
        return this
    }
}

var list = new LinkList()


list.push('a').push('b').push('c')

console.log(list)
```

> åŒå‘ prev, next

```js
// åŒå‘
class Node{
  constructor(val){
    this.val = val;
    this.prev=null;
    this.next=null;
  }
}

class twoWayList{
        constructor(){
            this.first=null;
            this.last = null;
            this.size =0;
    }
    addFirst = val =>{
        let node = new Node(val);
        if(this.size===0) {
            this.first = this.last = node;
        } else {
            node.next = this.first;
            this.fist.prev=node;
            this.first = node;
        }

        this.size++;
    }
    addLast = val => {
        let node = new Node(val);
        if(this.size===0) {
            this.first = this.last = node;
        } else {
            node.prev = this.last;
            this.last.next=node;
            this.last = node;
        }

        this.size++;
    }
    add=(index,val) =>{
        let node = new Node(val);
        let point = this.first;

        if(index===0) return this.addFirst(val);
        if(index===this.size) return thsi.addLast(val);
        if(index<0 || index>this.size) return;

        for(var i=1;i<index;i++) {
            point = point.next;
        }
        node.prev= point;
        node.next = point.next;
        point.next.prev = node;
        point.next = node;

        this.size++;
    }

    deleteFirst = ()=>{
        if(this.size===0) return;
        if(this.sieze===1) {
            this.first = this.last = null;
        } else {
            this.first = this.first.next;
            this.first.prev.next = null;
            this.first.prev = null;
        }

        this.sieze--;
    }

    deleteLast = () => {
        if(this.size===0) return;
        if(this.size===1) {
            this.first = this.last = null;
        } else {
            this.last = this.last.prev;
            this.last.next.prev = null;
            this.last.next = null;
        }

        this.sieze--;
    }
    delete = index => {
        let point = this.first;

        if(index===1) return this.deleteFirst();
        if(index === this.size) return this.deleteLast();
        if(index<=0 || index>this.size ) return;

        for(let i=1;i<index;i++) {
            point = point.next;
        }

        point.prev.next = point.next;
        point.next.prev = point.prev;
        point.prev = point.next = null;

        this.size--;
    }

    set = (index,val) => {
        let point = this.first;
        if(index<=0 || index>this.size) return;
        if(index===1) {
            return point.val=val;
        }

        for(var i=1;i<index;i++) {
            point= point.next;
        }
        point.val = val;

    }
    get = (index) =>{
        let point = this.first;
        if(index<=0 || index>this.size) return;
        if(index===1) {
            return point.val;
        }

        for(var i=1;i<index;i++) {
            point= point.next;
        }

        return point.val;
    }
}
```
