# P47

> 最长回文子串问题

**⚡题目**：

❓ 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000

示例 1：
输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。

## 思考 ⌚

- 暴力穷举法：所有子串，判断回文：枚举子串需要两层循环，对应的复杂度是 O(n^2)；判断是否回文，又额外需要 O(n)的开销。因此，这个暴力解法的时间复杂度就是 O(n^3)。
- 最值问题，使用动态规划

## 尝试 ⌛

## 优解 🚀

> 动态规划

- 由于定位任意子串需要的是两个索引，因此我们的状态数组应该是一个二维数组

```js
// 初始化一个二维数组
let dp = [];
const len = s.length
for (let i = 0; i < len; i ++) {
    dp[i] = [];
};
```

- 因此dp[i][j]不必额外记录长度这个状态，只需要记录该区间内的字符串是否回文。这里我们把回文记为 1（或true），不回文记为0（或false），长度 j - i + 1;

s[i] === s[j]。这种情况下，只要以 s[i+1]和s[j-1]为端点的字符串是回文字符串，那么 dp[i][j] = 1 就成立，否则 dp[i][j] = 0。
s[i] !== s[j]。这种情况下，一定有 dp[i][j]=0。

```js
// 状态转移方程
if(s[i] === s[j]) {
    dp[i][j] = dp[i+1][j-1]  
} else {
    dp[i][j] = 0
}
```

- 边界值： i===j，则单字母，必是回文。因此dp[i][i] = 1 就是这道题的边界值（或者说初始值）。
- dp[i][i+1] 是两个相同字母，也是回文，因此d[i][i+1] = 1;

```js
/**
 * @param {string} s
 * @return {string}
 */
const longestPalindrome = function(s) {
  const dp = [];
  // 缓存字符串长度
  const len = s.length
  // 初始化状态二维数组
  for (let i = 0; i < len; i ++) {
      dp[i] = [];
  };

  // 初始化最长回文子串的两个端点值
  let st = 0, end = 0
  // 初始化最长回文子串的初始值为1
  for(let i = 0; i<len; i++) {
      dp[i][i] = 1
      // 处理d[i][i+1]
      if(i+1 < len && s[i] === s[i+1]) {
        dp[i][i+1] = 1;

        // 更新端点
        st = i;
        end = i+1;
      }
  }

  // n 代表子串的长度，从3开始递增, 则 end - st 递增
  for(let n = 3; n <= len; n++) {
    // 实现转移方程 j - i + 1 = n, 所以len - n
    for(let i = 0; i <= len - n; i++) {
      let j = n + i - 1;

      // [i, j]内部回文
      if (dp[i+1][j-1]) {
        if (s[i] === s[j]) {
          // 若定位到更长的回文子串，则更新目标子串端点的索引值
          dp[i][j] = 1
          st = i
          end = j
        }
      }
    }
  }

  // 获取回文串
  return s.substring(st, end+1);
}
```
