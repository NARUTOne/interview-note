# 垃圾回收

**⚡题目**:

浏览器怎么进行垃圾回收❓
浏览器中不同类型变量的内存都是何时释放❓
哪些情况会导致内存泄露？如何避免❓
`weakMap weakSet` 和 `Map Set` 有什么区别❓

## 优解 🔥

> 不被使用的数据，专业名词叫「不可达」的数据, 这就是需要回收的垃圾数据。

[垃圾回收了解](https://mp.weixin.qq.com/s/qMnMkLvzbeEct_jpcMAl7g)

### 垃圾回收算法

v8的**可达性算法**：

1、从根节点遍历，区分标记：可达、不可达

根节点有很多，主要包括这几种：

- 全局变量 window，位于每个 iframe 中
- 文档 DOM 树
- 存放在栈上的变量
- 其他...

2、回收不可达所占内存
3、整理存在的内存碎片（不连续内存空间）

### 垃圾回收时机

> 避免垃圾回收时，导致JS脚本的暂停执行，引起应用的卡顿

- 分代收集：`主垃圾回收器 => 老生代`；`副垃圾回收器 => 新生代`

**临时对象（新生代）**：

大部分对象在内存中存活的时间很短。
比如函数内部声明的变量，或者块级作用域中的变量。当函数或者代码块执行结束时，作用域中定义的变量就会被销毁。
这类对象很快就变得不可访问，应该快点回收。
因为副垃圾回收器操作比较频繁，所以为了执行效率，一般新生区的空间会被设置得比较小。
一旦检测到空间装满了，就执行垃圾回收。

**长久对象（老生代）**：

生命周期很长的对象，比如全局的 window、DOM、Web API 等等。
这类对象可以慢点回收。
它使用「标记-清除」的算法执行垃圾回收。

**垃圾检查回收**：

- 增量收集

如果脚本中有许多对象，引擎一次性遍历整个对象，会造成一个长时间暂停。
所以引擎将垃圾收集工作分成更小的块，每次处理一部分，多次处理。

- 闲时收集

垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响。

## 内存泄露

> 内存泄露是指你「用不到」（访问不到）的变量，依然占居着内存空间，不能被再次利用起来。

- 闭包里面的变量就是我们需要的变量，不能说是内存泄露。
